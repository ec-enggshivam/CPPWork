#include<iostream>
#include <string.h>

using namespace std;


/*
The job of using the object SayHello of class MyString created in main() has been delegated 
to function UseMyString(). Delegating work to this function has resulted in object SayHello 
in main() to be copied into argument Input used in UseMyString(). 
This is a copy generated by the compiler as the function has been declared to take Input as 
a parameter by value and not by reference. The compiler performs a binary copy of Plain Old 
Data such as integers, characters, and raw pointers. So the pointer value contained in
SayHello.Buffer has simply been copied to Input—that is, SayHello.Buffer points to
the same memory location as Input.Buffer. 
The binary copy did not perform a deep copy of the pointed memory location, and you
now have two objects of class MyString pointing to the same location in memory.
Thus, when the function UseMyString() returned, variable Input goes out of scope and
is destroyed. In doing so, the destructor of class MyString is invoked, and the destructor
code releases the memory allocated to Buffer via delete.
Note that this call to delete invalidates the memory being pointed to in object SayHello
contained in main(). When main() ends, SayHello goes out of scope and is destroyed.
This time, however, Line 26 repeats a call to delete on a memory address that is no
longer valid (released and invalidated via the destruction of Input). This double delete
is what results in a crash. Note that the debug assertion message it’s pointing at the 
object SayHello that was not destructed successfully.
*/
 class MyString
{
  private:
  char* Buffer;
  
  public:
  // Constructor
  MyString(const char* InitialInput)
  {
   if(InitialInput != NULL)
   {
	 Buffer = new char [strlen(InitialInput) + 1];
 	 strcpy(Buffer, InitialInput);
   }
	else
	Buffer = NULL;
  }

 	// Destructor
 	~MyString()
	{
 	cout << "Invoking destructor, clearing up" << endl;
 	if (Buffer != NULL)
 	delete [] Buffer;
 	}

 	int GetLength()
 	{
 	return strlen(Buffer);
 	}

 	const char* GetString()
 	{
 	return Buffer;
 	}
};

 void UseMyString(MyString Input)
 {
	cout << "String buffer in MyString is" << Input.GetLength();
 	cout << " characters long" << endl;
 
	cout << "Buffer contains: " << Input.GetString() << endl;
 	return;
 }

 int main()
 {
 	MyString SayHello("Hello from String Class");

 	// Pass SayHello as a parameter to the function
 	UseMyString(SayHello);

 	return 0;
 }
